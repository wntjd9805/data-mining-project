Abstract
Outlier rejection and, equivalently, inlier set optimiza-tion is a key ingredient in numerous applications in com-puter vision such as filtering point-matches in camera pose estimation or plane and normal estimation in point clouds. Several approaches exist, yet at large scale we face a combinatorial explosion of possible solutions and state-of-the-art methods like RANSAC, Hough transform, or Branch&Bound require a minimum inlier ratio or prior knowledge to remain practical. In fact, for problems such as camera posing in very large scenes these approaches be-come useless as they have exponential runtime growth.
To approach the problem, we present an efficient and general algorithm for outlier rejection based on “intersect-ing” k-dimensional surfaces in Rd. We provide a recipe for formulating a variety of geometric problems as find-ing a point in Rd which maximizes the number of nearby surfaces (and thus inliers). The resulting algorithm has linear worst-case complexity with a better runtime depen-dency on the requested proximity of a query to its result than competing algorithms, while not requiring domain specific bounds. This is achieved by introducing a space decompo-sition scheme that bounds the number of computations by successively rounding and grouping surfaces. Our recipe and open-source code1 enables anybody to derive such fast approaches to new problems across a wide range of do-mains. We demonstrate the approach on several camera posing problems with a large number of matches and low inlier ratio, achieving state-of-the-art results at significantly lower processing times. 1.

Introduction
Whether geometric verification of point matches for ab-solute pose, homography estimation or normal estimation in point clouds, outlier rejection is a key ingredient in nu-merous applications in computer vision. RANSAC [8] is a 1https://github.com/google-research/ google-research/tree/master/large_scale_voting common choice for the task as it has good quality/runtime tradeoffs for many practical problems. RANSAC however does not provide an optimality guarantee, requires a lower bound on the inlier ratio and its runtime increases exponen-tially with the outlier ratio, making it unusable for problems with few inliers. In contrast Branch&Bound methods [3, 6] are guaranteed to find the optimal solution, yet their worst-case runtime equals exhaustive search in parameter space.
Their practical use depends on the quality of the bounds which are problem specific and notoriously hard to find.
We propose an alternative approach that exhibits a linear runtime independent of the inlier ratio and that does not re-quire a lower bound on the fraction of inliers. We base our work on the efficient and general algorithm for solving ge-ometric incidence problems proposed by a subset of the au-thors in [1]. In a nutshell the authors show that voting [23] is equivalent to finding a point in Rd which is close to as many surfaces (and thus inliers) as possible among a given set of k-surfaces in Rd. While in [1] we proves theoreti-cal bounds for approximate incidences, we show a general scheme to formulate approximate incidences of surfaces in a unified algorithm and apply it to several inlier maximiza-tion problems. We obtain a globally optimal solution (up to a prescribed resolution ε) considerably faster. Our contri-butions: – We introduce the concept of general voting for outlier removal and its relation to our previous work on ap-proximate incidences in [1] to a wider computer vision audience and demonstrate its use for camera posing, ray intersection, and geometric model fitting. – All approaches have linear complexity and are there-fore applicable to very large problems that are infea-sible with RANSAC [8]. The worst case complex-ity (and performance in practice) is always better than other methods (voting [11] and B&B [14]) for suffi-ciently large inputs. – We demonstrate the scalability and versatility using a generalization of [23, 21] where we remove the re-quirement of calibrated cameras and known gravity di-rection, but instead solve for these unknowns. – We compare to the state-of-the-art [6] for 6 degree-of-1
freedom (6DoF) camera pose estimation and show that our approach is optimal and faster in practice. In com-parison to [6] our surface intersection algorithm pro-vides a tight upper bound on the score without problem specific knowledge. – We provide example-derivations and open-source code which serve as a tutorial for applying [1] to a range of outlier removal problems in computer vision. 2. The Family of General Alignment Problems
A large number of geometric vision problems can be viewed as general alignment problems in which we aim to bring items in set a A “close” to items in another set B by applying a transformation from a group of allowed trans-formations. Closeness is defined by some parameter ε > 0 and a distance metric, commonly the Hausdorff [12] dis-tance between items in A and B. Note that ε defines which items we consider close enough, which is part of the prob-lem definition — ε is not an approximation factor. 2.
Many outlier rejection problems can be framed as such an alignment problem. For example in structure-based lo-calization [17, 19] A is a set of rays in 3-space in the camera frame that we want to align with a set of 3d world points B.
In relative camera posing [9, 10] we align two sets of 3-rays such that the maximum number of pairs are ε-close. In all of these problems, one defines the items in A and B and the allowed transformation group and then solves an approxi-mate geometric incidence problem.
Any hypothetical match — a correspondence between an object in A and an object in B — defines a general sur-face that is embedded in the ambient d-space of transfor-mations. Therefore, we can solve the outlier rejection in linear time in the number of hypothetical matches by a vot-ing scheme: surfaces are “ε-intersected” in the d-space to locate the point close to most surfaces. This point repre-sents the solution to the alignment problem. 3. Proximity and Incidences using Surfaces
Our work is based on the findings of [1] and we introduce their approach and notation using 2D line fitting as a toy example. The authors formulate the maximum incidence problem as one of reporting points in Rd that are close to the maximal number of k-dimensional surfaces. Each sur-face σ ∈ S is given in parametric form where the first k coordinates x = (x1, . . . , xk) are the surface parameters.
Specifically, each σ is defined in terms of ℓ essential pa-rameters t = (t1, . . . , tℓ), and d − k additional free additive parameters f = (fk+1, . . . , fd), one free parameter for each 2Our algorithm is globally optimal (up to a prescribed resolution if we want linear time) and for simplicity we set the resolution to be also
ε throughout the paper dependent coordinate.3 The surface σ is parameterized by t and f (we then denote σ as σt,f ) and defined by
F (σ) : Rk × Rℓ → R(d−k) xj = F (σ) (x; t) + fj, j for j = k + 1, . . . , d. (1)
Without loss of generality the voting space is scaled to be the unit cube [0, 1]d to simplify runtime complexity ex-pressions. Unbounded parameters are either still bounded in practice or can be transformed in the problem parameter-ization as is common in B&B (e.g. cos(θ) for line fitting).
For the toy example of 2D line fitting, we are given a set of points in 2D to which we want to fit a 2D line: We want to find the line that is ε-close to the maximum number of points.
In order to formulate this problem within our surface proximity scheme we use standard duality [2] which maps points to lines and lines to points. This allows us to find a point in 2D which is ε-close to the maximum number of points instead. Each input point is mapped into a k = 1 dimensional surface (a line) embedded in the Rd=2 line parameter space. The surface equation in this case is x2 = a · x1 + b = F (σ) 2 (x1; a) + b, (2) where the only essential parameter is the slope t = (a) and the only free parameter is the offset f = (b). Consequently, the point in dual space Rd=2 with the most close surfaces corresponds to the line parameters (in the primal space) that fit the input points best.4 3.1. A Naive Voting Solution
Once we formulate a problem as a general surface con-sensus problem, we obtain a naive Algorithm 1:
Iterate the first k dimensions of the voting space on an
ε-grid and compute the dependent variables (xk+1, ..., xd) for each surface in an 3ε neighborhood box around each grid vertex. That is, for each vertex we collect all nearby surfaces at most ε apart from each other. Then use the de-pendent variable range to cast votes in the voting space. For higher dimensional spaces this enumeration becomes costly, since the algorithm is independent of the actual structure of the surfaces and always takes O(n/εk) time for n k-dimensional surfaces. 3.2. Efficient Canonized Generalized Voting
Algorithm 2 is our generalized voting procedure based on the work in [1]. We propose a coarse-to-fine scheme 3We separate essential from free parameters in notation, since they will be handled differently in the algorithm that follows. 4Technically, we introduce some error, since duality preserves only ver-tical distances between lines and points, not Euclidean distances. We keep the error bounded by separating lines into two groups: lines with slope a′ ∈ [−1, 1] and lines with the inverse slope a′ = 1/a = [−1, 1], re-sulting in the two voting spaces (x1, x2) and (x2, x1) that have a 1-to-1 correspondence for each point in the space. When searching a maximum, we have to consider the sum of both spaces.
Algorithm 1: Naive Voting
Data: S: surfaces, B: box in [0, 1]d, ε: distance
Result: Point in B (among all ε-grid points) with the maximum of ε-close surfaces. for all s ∈ S do for all k-dimensional ε-cells in B do
Compute the d − k dependent variables using the surface equations.
Tally a vote for the d-tuple and add s into the set of inliers corresponding to it.
/* The d-tuple is the concatenation of the k-tuple and the dependent d − k-tuple */ end end return The center of the cell with maximum votes and its corresponding set of intersecting surfaces. that decomposes the search space to significantly improve the runtime complexity. We round surfaces so that we can group similar surfaces for joint processing, without affecting the outcome of the computation. This canon-ization means that in every recursive step of the algo-rithm (similar to levels in an octree decomposition) there are approximately the same number of surfaces to pro-cess. The consequence is a worst case runtime complexity of O(n + polylog(1/ε)/εℓ+d−k) (see Theorem 4.4 in [1]) or
O(n + 1/εℓ+d−k) ignoring log factors. For sufficiently large n generalized voting is thus always asymptotically faster than naive voting because of the multiplicative influence of n on the approximation cost in naive voting.
Algorithm 2: Efficient Generalized Voting
Data: S: surfaces, B: box in [0, 1]d, ε: distance
Result: Point in B (among all ε-grid points) with the maximum of ε-close surfaces.
Function SurfaceConsensus(S, B, ε): if Diam(B) ≤ ε then return (Bc, S) /* Bc is the center of B */ end
Canonize all surfaces S (for B) to a new set Sc.
Subdivide B to 2d sub-boxes, Bi.
For each sub-box Bi, find a subset Sci ⊂ Sc of surfaces that intersect it. for all Sci do (pi, Ii) = SurfaceConsensus(Sci, Bi,
ε)
/* pi: a point in Bi, Ii: the set of inliers */ end return (pk = argmaxpi |Ii|, Ik) 3.2.1 Algorithm and Implementation
Given an outlier removal problem, the first step is to formu-late surfaces with a parametric representation as in Eq. (1).
From constraints to general voting. We start with a set of constraints, each of which implicitly defines a surface embedded in Rd (by the points that satisfy the constraint).
The surface may have only k ≤ d dimensions, meaning that given x1, ..., xk, we can compute the other xk+1, ...xd. To use our framework, we have to provide two functions: 1. A predicate that returns whether a given surface inter-sects a box in Rd. 2. A function F (σ)(x, t) + f that computes the d − k de-pendent variables, given the other k variables.
In the example of 2D line fitting, Eq. (2), every 2D point (x1, x2) defines a line in voting space and with k = 1, we have a d − k = 1 dimensional surface embedded in the 2D ambient space. Function (1) computes whether ax1 + b intersects the given box B and function (2) is x2 = ax1 + b.
Canonization. Most Branch&Bound algorithms subdivide the parameter space, discarding branches early based on computed scores. In 3D, a common such subdivision is the octree; in the following we will call the subdivision scheme an octree, independent of the actual dimensionality. A key ingredient that makes our generalized voting algorithm effi-cient is Canonization; a surface rounding process we apply before recursing to the next level of the octree. Surfaces which are close to each other in the current box are rounded and grouped into the same surface, thus bounding the over-all number of surfaces.
Each surface σt,f is rounded carefully to σs,g to not change intersections on the finest level of the octree:
|(Fj(x; t) + fj) − (Fj(x; s) + gj)| ≤ ε j = k + 1, ..., d where ε is the “target closeness” introduced in Section 2.
Due to this bound, the surface rounding does not change the optimization result, while significantly reducing the number of surfaces to process. During canonization we keep track of merged surfaces to recover the original surfaces (the set of inliers) after finding the maximum.
Due to the depth of the octree, we round each surface at most log 1/ε times, each time introducing a rounding error c that is defined by the Lipschitz constant, a bound on the surface gradient. So the error we can tolerate in one round-ing step is ε′ = c log 1/ε . Using this constant, [1] derives rounding rules for the surface parameters: Round free pa-rameters to multiples of ε′/(ℓ + 1) and essential parameters to multiples of ε′/(ℓ + 1)δ where δ is the diameter of the current box of the octree. See [1] for additional detail.
ε
(cid:16) (cid:17) n log (1−bk) outlier rejection problems. The RANSAC complexity is for a lower bound b on the fraction of inliers,
O a minimal set size k needed to define a possible solution and n input constraints. This is linear in n only when b is a con-stant and even then it grows quickly when b is decreasing, making RANSAC unattractive for large scale problems.
Figure 1: Canonization where the surface is a line in 2D, which is intersected with a 2D box in the search quadtree.
Figure 1 shows the rounding process for the case of a 2D surface given by x2 = ax1 + b and a box B. Note that our goal is to find a surface which is close to the input surface within the box B. We first round the essential parameter a to a′ which moves the line away from the box, so we translate it by changing b and then rounding it to b′. The key result is that the number of canonical surfaces in B is upper bounded independent of the number of input surfaces.
In practice, ε′ determines the runtime upper bound and the best parameter can vary among coordinates such that we tune constants per parameter (e.g. different ε′ for a and b in the line fitting example).
General surface-box intersection algorithm for any sur-face and box: Suppose the surface σ is given as a poly-nomial equation F (x1, x2, x3) = 0 and that the box is
B = [0, 1]3. If we assume σ is connected, then σ inter-sects B if either (1) σ is fully contained in B, or (2) it intersects some face, or (3) it intersects some edge. To test for case (1), pick an arbitrary point on σ and test if it lies in B. If σ is not connected, repeat this for one point in each connected component. Cases (2) and (3) are han-dled recursively: for (2), intersect each face with the 2D plane, e.g. with F (x1, x2, 0) = 0, by checking a point on (each connected component of) the surface and each edge of the face. For (3) we have a univariate polynomial, e.g.
F (x1, 0, 0) = 0, and we need to test if it has a root in [0, 1].
This intersection algorithm can become slow for many dimensions but we found that using a subset of the condi-tions is a good approximation in practice. 3.3. Theoretical Analysis of