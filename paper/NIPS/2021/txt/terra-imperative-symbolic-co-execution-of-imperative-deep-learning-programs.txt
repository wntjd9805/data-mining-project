Abstract
Imperative programming allows users to implement their deep neural networks (DNNs) easily and has become an essential part of recent deep learning (DL) frame-works. Recently, several systems have been proposed to combine the usability of imperative programming with the optimized performance of symbolic graph execu-tion. Such systems convert imperative Python DL programs to optimized symbolic graphs and execute them. However, they cannot fully support the usability of imper-ative programming. For example, if an imperative DL program contains a Python feature with no corresponding symbolic representation (e.g., third-party library calls or unsupported dynamic control ﬂows) they fail to execute the program. To overcome this limitation, we propose Terra, an imperative-symbolic co-execution system that can handle any imperative DL programs while achieving the optimized performance of symbolic graph execution. To achieve this, Terra builds a symbolic graph by decoupling DL operations from Python features. Then, Terra conducts the imperative execution to support all Python features, while delegating the decoupled operations to the symbolic execution. We evaluated Terra’s performance improve-ment and coverage with ten imperative DL programs for several DNN architectures.
The results show that Terra can speed up the execution of all ten imperative DL programs, whereas AutoGraph, one of the state-of-the-art systems, fails to execute
ﬁve of them.
∗Work done at Seoul National University
†Corresponding author 35th Conference on Neural Information Processing Systems (NeurIPS 2021).
1

Introduction
The rapid evolution of deep neural networks (DNNs) has been fueled by the support of deep learning (DL) frameworks [6, 32]. Such frameworks provide users with a programming layer to build and execute DNNs, commonly adopting Python as their host language. Typically, they execute DL programs with one of the two execution models: imperative or symbolic execution. In the former, the
Python interpreter executes a DL program as a normal program, invoking DL operations on-the-ﬂy.
The invoked DL operations are executed on a separate DL accelerator asynchronously, and the Python interpreter continues running the program. The dynamic control ﬂows of the DL operations are naturally expressed by the interpretation of the program, and users can utilize any functionalities of
Python (e.g., dynamic typing and third-party libraries [9, 16]) while executing DL operations. On the other hand, in the latter model, the Python interpreter embeds DL operations into a symbolic graph that represents the entire dataﬂow of a DNN. Thus, users should deﬁne their DL programs only with existing symbolic operations that DL frameworks support. In other words, the dynamic control ﬂows of a DNN should be explicitly represented by control ﬂow operations (e.g., tf.cond and tf.while of TensorFlow). However, the symbolic execution can take advantages of various optimization techniques because the symbolic graph contains a whole computation lineage of a DNN architecture.
Although symbolic execution achieves higher performance compared to imperative execution, imper-ative execution has been preferred because of its usability. Several systems [2, 3, 4, 15, 19, 29, 39] have been proposed to match the speed of symbolic execution while enjoying the beneﬁt of imperative execution. These systems attempt to generate a symbolic graph that represents an entire imperative program and execute the graph instead of imperatively running the program. Methods for generating the symbolic graph can be broadly classiﬁed into two approaches: single path tracing and static compilation. The former approach generates a symbolic graph by imperatively executing a single iteration of a program and recording the executed DL operations. Systems that adopt the latter approach translate the abstract syntax tree (AST) of a program into a symbolic graph.
Unfortunately, both approaches can correctly handle only a subset of imperative DL programs. For example, dynamic control ﬂows in an imperative program are not captured by the single path tracing approach. On the other hand, the static compilation approach cannot correctly generate a symbolic graph if a target program contains an AST node that does not have a corresponding symbolic operation such as try-excepts, generators, Python object mutations, and third-party library calls. As a result, it is up to the users to clearly understand the limited usability of these systems.
In this paper, we propose Terra, an imperative-symbolic co-execution system that addresses the limi-tations. While the previous approaches replace the imperative execution with the symbolic execution,
Terra maintains the imperative execution to support all Python features where DL operations are delegated to the symbolic execution. Also, Terra generates a symbolic graph by utilizing multiple traces of an imperative program. To be speciﬁc, Terra imperatively runs an imperative DL program for several iterations and collects traces, each of which is a linear chain of DL operations sorted by the execution order. The collected traces are merged into a TraceGraph, a directed acyclic graph (DAG) that encapsulates the captured DL operations along with their diverse execution orders. Terra stops collecting traces when the trace of the latest iteration is already embedded in the TraceGraph.
To generate an executable symbolic graph from the TraceGraph, Terra adds additional information to the TraceGraph. First of all, Terra annotates the TraceGraph to enable communication between the imperative execution and the symbolic execution. In addition, Terra further analyzes the TraceGraph to insert control ﬂow operations explicitly, so that a symbolic graph can be executed with the DL operations in a certain trace. After generating a symbolic graph from the TraceGraph, Terra starts the co-execution of a skeleton imperative program, in which DL operations are not performed, and the symbolic graph that represents the DL operations. Here, Terra continually checks whether the current trace is being expressed by the TraceGraph. If Terra detects a new trace, Terra discards the symbolic graph and collects more traces by running the original program imperatively. Terra then re-generates the symbolic graph and restarts the co-execution. Consequently, Terra is able to run any imperative DL programs correctly and efﬁciently even if it contains the Python features that the previous approaches cannot handle.
We have implemented Terra on TensorFlow v2.4.1 and compared Terra with TensorFlow’s imperative execution [7] and AutoGraph [29]. Our evaluation shows that Terra can train ten imperative DL programs including convolutional neural networks, transformer-based networks, and generative 2
(a) third-party library call & tensor materialization (b) dynamic control ﬂow (c) Python object mutation
Figure 1: Simple examples that the static compilation approach cannot deal with. Note that AutoGraph could silently produce an incorrect result in the Python object mutation case. adversarial networks up to 1.73x faster than the original imperative execution. However, AutoGraph fails to support ﬁve programs for three reasons: third-party library call, Python object mutation, and tensor materialization during conversion, which we describe in § 2.2. 2