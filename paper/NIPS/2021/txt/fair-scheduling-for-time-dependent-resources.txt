Abstract
We study a fair resource scheduling problem,nwhere a set of interval jobs are to be allocated to heterogeneous machines controlled by intellectual agents. Each job is associated with release time, deadline and processing time such that it can be processed if its complete processing period is between its release time and deadline.
The machines gain possibly different utilities by processing different jobs, and all jobs assigned to the same machine should be processed without overlap. We consider two widely studied solution concepts, namely, maximin share fairness and envy-freeness. For both criteria, we discuss the extent to which fair allocations exist and present constant approximation algorithms for various settings. 1

Introduction
With the rapid progress of AI technologies, AI algorithms are widely deployed in many societal settings such as the distribution of job and education opportunities where complex social effects may signiﬁcantly diminish the performance of the algorithms. To motivate our study, let us consider a problem faced by the Students Affairs Ofﬁce (SAO). An SAO clerk is assigning multiple part-time jobs to the students who submitted job applications. Each part-time job occupies a consecutive time period within a possibly ﬂexible interval. For example, an one-hour math tutorial needs to be given between 8:00am and 11:00am on June 26th. A feasible assignment requires that the jobs assigned to an applicant can be scheduled without mutual overlap. The students are heterogeneous, i.e., different students may hold different job preferences. It is important that the students are treated equally in terms of getting job opportunities, and thus the clerk’s task is to make the assignment fair.
The SAO problem falls under the umbrella of the research on job scheduling, which has been studied in numerous ﬁelds, including operations research Gentner et al. [2004], machine learning Paleja et al. [2020], parallel computing Drozdowski [2009], cloud computing Al-Arasi and Saif [2020], etc.
Following the convention of job scheduling research, each part-time job, or job for short, is associated with release time, deadline, and processing time. The students are modeled as machines, who have different utility gains for completing jobs. Traditionally, the objective of designing scheduling algorithms is solely focused on efﬁciency or proﬁt. However, motivated by various real-world AI driven deployments where the data points of the algorithms are real human beings who should be
∗Equal contribution
†Corresponding author 35th Conference on Neural Information Processing Systems (NeurIPS 2021).
treated unbiasedly, addressing the individual fairness becomes important. Accordingly, the past several years has seen considerable efforts in developing fair AI algorithms Chierichetti et al. [2017], where combinatorial structures are incorporated into the design, such as vertex cover Rahmattalabi et al. [2019], facility location Chen et al. [2019] and knapsack Amanatidis et al. [2020].
It is noted that people have different criteria on evaluating fairness, and in this work, we consider two of the most widely accepted deﬁnitions. The ﬁrst is motivated by the max-min objective, i.e., maximizing the worst-case utility, which has received observable attention for various learning scenarios Rahmattalabi et al. [2019]. However, for heterogeneous agents, optimizing the worst case is not enough, as different people have different perspectives and may not agree on the output.
Accordingly, one popular research agenda is centered around computing an assignment such that everyone believes that it (approximately) maximizes the worst case utility. This criterion is named maximin share (MMS) fairness in Budish [2010]. The second one is envy-freeness (EF), which has been very widely studied in social sciences and economics but arguably less explored in machine learning. Informally, an assignment is called EF if everyone believes she has obtained the best resource compared with any other agent’s assignment. We note that, due to the scheduling-feasible constraint, some jobs may not be allocated. Thus EF alone is not able to satisfy the agents as keeping all resources unallocated does not incur any envy among them, but the agents envy the charity where unallocated/disregarded items are assumed to be donated to a charity. To resolve this issue, in this work, we want to understand how we can compute allocations that are simultaneously EF and Pareto efﬁcient (PO), where an allocation is called PO if there does not exist another allocation that makes nobody worse off but somebody strictly better off.
Recently, Chiarelli et al. [2020] and Hummel and Hetland [2021] studied the fair allocation of conﬂicting items, where the items are connected via graphs. An edge between two items means they are in conﬂict and should be allocated to different agents. However, in our model, the conﬂict among items cannot be described as the edges in a graph. For example, two one-hour tutorials between 9:00am and 11:00am can be feasibly scheduled, but three such tutorials are not feasible any more.
For a comprehensive introduction to the various constraints, including conﬂict constraints, studied in fair division, we refer the interested reader to the recent survey of Suksompong [2021]. 1.1 Main Results
We study the fair interval scheduling problem (FISP), where fairness is captured by MMS and EF.
For each of them, we design approximation algorithms to compute MMS or EF1 schedules.
Maximin Share. Informally, a machine’s MMS is deﬁned to be her optimal worst-case utility in an imaginary experiment: she partitions the items into m bundles but was the last to select one, where m is the number of agents. It is noted that as the machines are heterogeneous, they may not have the same MMS value. Our task is to investigate the extent to which everyone agrees on the ﬁnal allocation. A job assignment is called α-approximate MMS fair if every machine’s utility is no less than α fraction of her MMS value. Our main result in this part is an algorithmic framework which ensures a 1/3-approximate MMS schedule, and thus improves the best known approximation of 1/5 which is proved for a broader class of valuation functions – XOS Ghodsi et al. [2018]. Interestingly, in the independent and parallel work Hummel and Hetland [2021], the authors also show the existence of 1/3-approximate MMS for graphically conﬂicting items. With XOS valuation oracles, Ghodsi et al. [2018] also designed a polynomial-time algorithm to compute a 0.125-approximate MMS allocation. As a comparison, by slightly modifying our algorithm, it returns a 0.24-approximate MMS allocation in polynomial time, without valuation oracles. When all jobs are rigid, i.e., processing time = deadline - release time, our problem degenerates to ﬁnding a partition of an interval graph such that the minimum weight of the independent set for each subgraph is maximized. Recently, a pseudo-polynomial-time algorithm is given in Chiarelli et al. [2020] for constant number of agents.
In this sense, we generalize this problem to ﬂexible jobs and design approximation algorithms for arbitrary number of agents.
Main Result 1. For an arbitrary FISP instance, there exists a 1/3-approximate MMS schedule, and a (0.24 − (cid:15))-approximate MMS schedule can be found in polynomial time, for any constant (cid:15) > 0.
EF1+PO. EF is actually a demanding fairness notion, in the sense that any approximation of EF is not compatible with PO. Instead, initiated by Lipton et al. [2004], most research is focused on its relaxation, envy-freeness up to one item (EF1), which means the envy between two agents may exist 2
but will disappear if some item is removed. Unfortunately, EF1 and PO are still not compatible even if all jobs are rigid and agents have unary valuations. However, the good news is, if all jobs have unit processing time, an EF1 and PO schedule is guaranteed to exist and can be found in polynomial time. This result continues to hold when agent valuations are weighted but identical. It is shown in
Biswas and Barman [2018] that under laminar matroid constraint an EF1 and PO allocation exists when agents have identical utilities, but ﬁnding it may need exponential time. We improve this result in two perspectives. First, our feasibility constraints, even for unit jobs, are not necessarily laminar matroid. Second, our algorithm runs in polynomial time.
Main Result 2. No algorithm can return an EF1 and PO schedule for all FISP instances, even if all jobs are rigid and valuations are unary. When all jobs have unit processing time and valuations are (weighted) identical, an EF1 and PO schedule can be computed in polynomial time.
Although exact EF1 and PO are not compatible, we prove that for an arbitrary FISP instance, there always exists a 1/4-approximate EF1 and PO schedule, which coincides with Wu et al. [2021]. If all jobs have unit processing time, a 1/2-approximate EF1 and PO schedule exists. To prove this result, we consider Nash social welfare – the geometric mean of all machines’ utilities. We show that a Nash social welfare maximizing schedule satisﬁes the desired approximation ratio. This result is in contrast to the corresponding one in Caragiannis et al. [2016], which shows that without any feasibility constraints, such an allocation is EF1 and PO. We also show that both approximations are tight.
Main Result 3. For any FISP instance, the schedule maximizing Nash social welfare is PO and 1/4-approximate EF1. If all jobs have unit processing time, it is 1/2-approximate EF1.
EF1+IO By above results, we observe that PO is too demanding to measure efﬁciency in our model.
One milder requirement is individual optimality (IO). Intuitively, an allocation is called IO if every agent gets the best feasible subset of jobs from the union of her current jobs and unscheduled jobs.
We show that EF1 is still not compatible with IO in the general case. But for unary valuations, we obtain positive results and design polynomial time algorithms for (1) computing an EF1 and IO schedule for rigid jobs, and (2) computing an EF1 and 1/2-approximate IO schedule for ﬂexible jobs.
To prove these results, we utilize two classic algorithms Earliest Deadline First and Round-Robin.
We defer this part completely to the full version Li et al. [2021]. 1.2 Other