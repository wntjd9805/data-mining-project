Abstract
We train hierarchical Transformers on the task of synthesizing hardware circuits directly out of high-level logical speciﬁcations in linear-time temporal logic (LTL).
The LTL synthesis problem is a well-known algorithmic challenge with a long history and an annual competition is organized to track the improvement of algo-rithms and tooling over time. New approaches using machine learning might open a lot of possibilities in this area, but suffer from the lack of sufﬁcient amounts of training data. In this paper, we consider a method to generate large amounts of additional training data, i.e., pairs of speciﬁcations and circuits implementing them.
We ensure that this synthetic data is sufﬁciently close to human-written speciﬁ-cations by mining common patterns from the speciﬁcations used in the synthesis competitions. We show that hierarchical Transformers trained on this synthetic data solve a signiﬁcant portion of problems from the synthesis competitions, and even out-of-distribution examples from a recent case study. 1

Introduction
In reactive synthesis, a circuit is automatically constructed from a logical speciﬁcation given as a formula in linear-time temporal logic (LTL). LTL is widely used by the veriﬁcation community and is the basis for industrial speciﬁcation languages like the IEEE standard PSL [24]. Efﬁcient synthesis tools for LTL would simplify the hardware design process: a hardware designer could focus on specifying what the circuit is supposed to compute, instead of implementing how the computation is done. LTL synthesis procedures, however, have to invoke involved reasoning engines, which turn often out to be infeasible when facing real-world problem instances. Much research has been conducted to push this form of hardware construction process closer to practice (see, for example, the synthesis of the AMBA protocol [5]). The high computational complexity of the general problem (2-EXPTIME-complete), however, is so far a barrier that seems insurmountable with classical, e.g., automaton-based, approaches. Recent successful applications of machine learning for logical tasks, such as SAT solving [45, 46], higher-order theorem proving [36, 3], and the LTL trace generation problem [22] encourage new approaches to the LTL synthesis problem using machine learning.
Similar to the success of machine learning for program synthesis, e.g., [37, 20, 42], machine learning approaches might open a lot of possibilities in hardware synthesis. For example, secondary design 35th Conference on Neural Information Processing Systems (NeurIPS 2021).
(assumptions) (¬(i0))) ( ( ((¬(o2)) ∨(((¬(i4)) ∧(¬(i1))) U((¬(i4)) ∧(i1)))))
→ (guarantees:) ((i0) →( ((i2) →( ((i1) →( ( ( ((¬(i0)) ∨(o4)))) (o0))) (o0))) (o4))) →( (( (o3))) (i4)) ∧( (i1)))) ((i4) →( ( ((¬(o4)) ∨(¬(o2)))) ((o1) →( ((i1) R(((i1) →(o2)) ∧((¬(i1)) →(o0)))))) (( (o3)) →(i3))
Figure 1: A speciﬁcation in our test set, consisting of 2 assumption patterns and 8 guarantee patterns (left). A circuit, predicted by a hierarchical Transformer, satisfying the speciﬁcation (right). goals, which cannot be easily formalized, might be incorporated into the process using natural language. Applying machine learning to the area of hardware synthesis, however, suffers from a severe lack of sufﬁcient amounts of training data.
In this paper, we consider a method to generate large amounts of additional training data, i.e., pairs of speciﬁcations and circuits implementing them. We show that hierarchical Transformers [33] can be trained on the circuit synthesis problem using the generated data and that the models can solve a signiﬁcant portion of problems from the annual synthesis competition. In practice, logical hardware speciﬁcations follow speciﬁc design patterns [12]. To cope with the data scarcity of this problem, we propose a method that makes use of speciﬁcation patterns, from which data for a successful training can be derived.
), a request r must be eventually ( (r → g). The formula
For example, a common LTL speciﬁcation pattern looks as follows: describes a response property, stating that at every point in time (
) followed by a grant g. We obtain these patterns from the annual reactive synthesis competition [25].
We mined 2099 speciﬁcation patterns from 346 benchmarks, which we split into assumption patterns and guarantee patterns. Assumption patterns restrict the space of possible inputs (environment behavior), and guarantee patterns describe how the circuit has to react to the environment. From these speciﬁcation patterns, we generate larger speciﬁcations by conjoining assumption patterns to a speciﬁcation ϕA and by conjoining guarantee patterns to a speciﬁcation ϕG. The implication
ϕA → ϕG forms the ﬁnal speciﬁcation of the circuit. We obtained 200 000 speciﬁcations and used classical synthesis tools [14, 35] to compute circuits satisfying the speciﬁcations. Figure 1 shows an example held-out speciﬁcation constructed in this fashion and a circuit predicted by one of our models (details on the data representation can be found in Section 3). When checking, the predicted circuit indeed satisﬁes the speciﬁcation.
To train a machine learning model on the LTL synthesis task, we represent the decomposed speci-ﬁcations and circuits as sequences and use hierarchical Transformers [33]. We show that many of the model’s predictions that differ from the circuits in our dataset satisfy the speciﬁcations when verifying the predictions1, i.e., the model constructs a different, yet correct solution. When using a beam search, models achieve an accuracy of up to 79.9% on our synthetic test data and up to 66.8% on the original formulas from SYNTCOMP. The Transformer can even solve out-of-distribution formulas, taken from a recent case study [1], i.e., formulas that were not used for the speciﬁcation pattern mining. Furthermore, the models can solve generated test instances on which classical LTL synthesis tools timed out. In practice, it is essential to handle both realizable (i.e., when a hardware implementation exists) and unrealizable (i.e., when no hardware implementation exists) speciﬁca-tions. We demonstrate that our approach achieves similar results on both realizable and unrealizable speciﬁcations. 1Note that verifying the solutions, i.e., model-checking, is a by-far easier problem (PSPACE vs 2-EXPTIME) and can typically be done in a fraction of the time needed to synthesize the circuits classically. 2
The remainder of this paper is structured as follows: