Abstract
The goal of program synthesis from examples is to ﬁnd a computer program that is consistent with a given set of input-output examples. Most learning-based approaches try to ﬁnd a program that satisﬁes all examples at once. Our work, by contrast, considers an approach that breaks the problem into two stages: (a)
ﬁnd programs that satisfy only one example, and (b) leverage these per-example solutions to yield a program that satisﬁes all examples. We introduce the Cross
Aggregator neural network module based on a multi-head attention mechanism that learns to combine the cues present in these per-example solutions to synthesize a global solution. Evaluation across programs of different lengths and under two different experimental settings reveal that when given the same time budget, our technique signiﬁcantly improves the success rate over PCCoder [30] and other ablation baselines. The code, data and trained models for our work can be found at: https://github.com/shrivastavadisha/N-PEPS. 1

Introduction
Program synthesis from examples tackles the problem of coming up with a computer program that satisﬁes a given set of Input-Output (IO) examples. Since the space of possible programs is large, an exhaustive search can be extremely time-consuming. Therefore, development of systems for program synthesis that can come up with a solution (program satisfying the given IO examples) within a limited time, such that it is practical for real-world applications, is a challenging task.
Neural-guided program synthesis systems [4, 30] try to expedite the search by using a neural network conditioned on the IO examples as a learned heuristic for the search procedure. In these systems, a neural network outputs probabilities over programs or properties of programs (e.g. functions). These probabilities are then utilized to guide a search like depth-ﬁrst or beam search. These systems try to ﬁnd a program that satisﬁes all IO examples simultaneously, which under most of the settings can be hard. What if instead, we try to ﬁnd this program in parts? To understand this motivation, imagine a process wherein a programmer is asked to write a program that satisﬁes a set of unit test cases. They may begin by ﬁguring out a program that satisﬁes a subset of unit test cases ﬁrst, and later modifying the program to incorporate other corner cases. Shi et al. [26] uses this intuition to iteratively reﬁne a program by mining fragments of Java code from partial solutions, based on a set of rules and predeﬁned heuristics. Gupta et al. [12] also uses the same intuition, but in a different application for program repair.
In this work, we consider breaking the complex problem of ﬁnding a program that satisﬁes all N given IO examples (called the global solution) into N smaller, easy to solve sub-problems, where each sub-problem involves ﬁnding a program satisfying only one IO example (called per-example
∗Correspondence to: <dishu.905@gmail.com> 35th Conference on Neural Information Processing Systems (NeurIPS 2021).
Figure 1: Idea of N-PEPS: (Left) Illustrating the two stages of N-PEPS with an example; (Right)
Synthesizing line 2 of pg using contributions from CA and GPS, with details of how query, keys, values and relation scores are formed. White box shows an example of obtaining a PE state embedding. solution). The cues present in these per-example (PE) solutions are then combined to provide useful signals that can help guide the search for the global solution effectively. As a motivating example, consider the left part of Figure 1, where ﬁve IO examples are given as a speciﬁcation (green box) and we need to ﬁnd a global solution pg (red box) that satisﬁes these ﬁve examples. The ﬁrst stage of our approach consists of performing per-example searches to ﬁnd a program pi conditioned on the i-th
IO example. In our example, we start from IO example #1 and ﬁnd program p1. In addition, we also check if p1 satisﬁes any other examples (#3 in ﬁgure). Iterating through the examples in this way results in a set of programs (p1, p2, p3) that, taken together, in the ideal scenario, would satisfy all ﬁve
IO examples. Looking closely at the discovered PE solutions, we see that they contain fragments of the global solution. This brings us to the second stage of our approach that addresses the challenge of how best to aggregate these PE solutions to produce a global solution. Towards that goal, we propose a neural network based architecture, which we refer to as Cross Aggregator (CA). It is designed to learn to combine the cues present in these PE solutions, in a way that helps guide the search for pg.
We model this aggregation using a multi-head cross-attention mechanism, which leverages the state of step-wise execution of the PE solutions and the synthesized global solution so far (see Section 3.2 for details). Our key contributions can be listed as follows:
• We consider breaking the standard program synthesis pipeline into two stages: (a) discovering PE solutions, and (b) aggregating the PE solutions such that it leads to a global solution. We refer to our approach that uses neural networks at both these stages as Neural Per-Example Program
Synthesis (N-PEPS).
• We propose a neural network based multi-head attention architecture called Cross Aggregator (CA) that makes use of step-wise execution information to learn to combine the PE cues such that it helps guide the search for the global solution.
• We demonstrate via experiments with programs of different lengths and under two different evaluation settings that when given the same time budget, our formulation shows signiﬁcant improvements in success rate when compared to PCCoder [30] (one of the leading techniques for neural-guided program synthesis) and other ablation baselines. 2