Abstract
In this paper, we consider domain-invariant deep learning by explicitly modeling domain shifts with only a small amount of domain-speciﬁc parameters in a Convo-lutional Neural Network (CNN). By exploiting the observation that a convolutional
ﬁlter can be well approximated as a linear combination of a small set of dictio-nary atoms, we show for the ﬁrst time, both empirically and theoretically, that domain shifts can be effectively handled by decomposing a convolutional layer into a domain-speciﬁc atom layer and a domain-shared coefﬁcient layer, while both remain convolutional. An input channel will now ﬁrst convolve spatially only with each respective domain-speciﬁc dictionary atom to “absorb" domain variations, and then output channels are linearly combined using common decomposition coef-ﬁcients trained to promote shared semantics across domains. We use toy examples, rigorous analysis, and real-world examples with diverse datasets and architectures, to show the proposed plug-in framework’s effectiveness in cross and joint domain performance and domain adaptation. With the proposed architecture, we need only a small set of dictionary atoms to model each additional domain, which brings a negligible amount of additional parameters, typically a few hundred. 1

Introduction
Training supervised deep networks requires large amount of labeled training data; however, well-trained deep networks often degrade dramatically on testing data from a signiﬁcantly different domain. In real-world scenarios, such domain shifts are introduced by many factors, such as different illumination, viewing angles, and resolutions. Research topics such as transfer learning and domain adaptation are studied to promote invariant representations across domains with different levels of availabilities of annotated data.
Recent efforts on learning cross-domain invariant representations using deep networks generally fall into two categories. The ﬁrst one is to learn a common network with constraints encouraging invariant feature representations across different domains [17, 19, 34]. The feature invariance is usually measured by feature statistics like maximum mean discrepancy, or feature discriminators using adversarial training [6]. While these methods introduce no additional model parameters, the effectiveness largely depends on the degree of domain shifts. The other direction is to explicitly model domain speciﬁc characteristics with a multi-stream network structure where different domains are modeled by corresponding sub-networks at the cost of extra parameters and computations [26].
In this paper, we model domain shifts through domain-adaptive ﬁlter decomposition (DAFD) with layer branching. At a branched layer, we decompose each ﬁlter over a small set of domain-speciﬁc dictionary atoms to model intrinsic domain characteristics, while enforcing shared cross-domain decomposition coefﬁcients to align invariant semantics. A regular convolution is now decomposed into two steps. First, a domain-speciﬁc dictionary atom convolves spatially only each individual input channel for shift “correction.” Second, the “corrected" output channels are weighted summed using 34th Conference on Neural Information Processing Systems (NeurIPS 2020), Vancouver, Canada.
domain-shared decomposition coefﬁcients (1×1 convolution) to promote common semantics. When domain shifts happen in space, we rigorously prove that such layer-wise “correction” by the same spatial transform applied to atoms sufﬁces to align the learned features, contributing to the needed theoretical foundations in the ﬁeld.
Comparing to the existing subnetwork-based methods, the proposed method has several appealing properties: First, only a very small amount of additional trainable parameters are introduced to explicitly model each domain, i.e., domain-speciﬁc atoms. The majority of the parameters in the network remain shared across domains, and learned from abundant training data to effectively avoid overﬁtting. Furthermore, the decomposed ﬁlters reduce the overall computations signiﬁcantly compared to previous works, where computation typically grows linearly with the number of domains.
We conduct extensive real-world face recognition (with domain shifts and simultaneous multi-domains inputs), image classiﬁcation, and segmentation experiments, and observe that, with the proposed method, invariant representations and performance across domains are consistently achieved without compromising the performance of individual domain.
Our main contributions are summarized as follows:
• We propose plug-in domain-invariant representation learning through ﬁlter decomposition with layer branching, where domain-speciﬁc atoms are learned to counter domain shifts, and semantic alignments are enforced with cross-domain common decomposition coefﬁcients.
• We both theoretically prove, contributing the much needed foundations in CNN-based invariant learning, and empirically demonstrate that by stacking the atom-decomposed branched layer, invariant representations across domains are achieved progressively.
• The majority of network parameters remain shared across domains, which alleviates the demand for massive annotated data from every domain, and introduces only a small amount of additional computation and parameter overhead. Thus the proposed approach serves as an efﬁcient way for domain invariant learning and its applications to domain shifts and simultaneous multi-domain tasks. (a) Regular CNN (b) Basic Branching (c) Branching with DAFD
Figure 1: Three candidate architectures considered for domain-invariant representation learning. In (a), a set of common network parameters are trained to model both source and target domains. In (b), the domain characteristics are explicitly modeled by two sets of convolutional ﬁlters in each convolutional layer. Our approach is illustrated in (c) where domain-adaptive atoms are learned to
“absorb" domain shifts, while the decomposition coefﬁcients are shared across domains to promote and exploit common semantics. 2 Domain-adaptive Filter Decomposition for Invariant Learning
A straightforward way to address domain shifts is to learn from multi-domain training data a single network as in Figure 1(a). However, the lack of explicitly modelling of individual domains often results in unnecessary information loss and performance degradation as discussed in [26]. Thus, we often simultaneously observe underﬁtting for domains with abundant training data, and overﬁtting for domains with limited training. In this section, we start with a simplistic pedagogical formulation, domain-adaptive layer branching as in Figure 1(b), where domain shifts are modeled by a respective 2
branch of ﬁlters in a layer, one branch per domain. Each branch is learned only from domain-speciﬁc data, while non-branched layers are learned from data from all domains. We then propose to extend basic branching to atom-decomposed branching as in Figure 1(c), where domain characteristics are modeled by domain-speciﬁc dictionary atoms, and shared decomposition coefﬁcients are enforced to align cross-domain semantics. 2.1 Pedagogical Branching Formulation
We start with the simple-minded branching formulation in Figure 1(b). To model the domain-speciﬁc characteristics, at the ﬁrst several convolutional layers, we dedicate a separate branch to each domain.
Domain shifts are modeled by an independent set of convolutional ﬁlters in the branch, trained respectively with errors propagated back from the loss functions of source and target domains. For supervised learning, the loss function is the cross-entropy for each domain. For unsupervised learning, the loss function for the target domain can be either the feature statistics loss or the adversarial loss.
The remaining layers are shared across domains. We assume one target domain and one source domain in our discussion, while multiple domains are supported. Note that, though we adopt the source vs. target naming convention in the domain adaptation literature, we address here a general domain-invariant learning problem.
Domain-adaptive branching is simple and straightforward, however, it has the following drawbacks:
First, both the number of model parameters and computation are multiplied with the number of domains. Second, with limited target domain training data, we can experience overﬁtting in deter-mining a large amount of parameters dedicated to that domain. Third, no constraints are enforced to encourage cross-domain shared semantics. We address these issues through layer branching with the proposed domain-adaptive ﬁlter decomposition. 2.2 Atom-decomposed Branching
To simultaneously counter domain shifts and enforce cross-domain shared semantics, we decompose each convolutional ﬁlter in a branched layer into domain-speciﬁc dictionary atoms, and cross-domain shared coefﬁcients, as illustrated in Figure 2.
In our approach, we decompose source and target domain ﬁlters over domain-adaptive dictionary atoms, with decompo-sition coefﬁcients shared across domains.
Speciﬁcally, at each branched layer, the source domain ﬁlter Ws and target domain
ﬁlter Wt of size L × L × C (cid:48) × C, are de-composed as Ws = ψsa and Wt = ψta, where ψs and ψt with a size of L × L × K are K domain-adaptive dictionary atoms for source and target domains, respec-tively; and a ∈ RK×C(cid:48)×C denotes the common decomposed coefﬁcients shared across domains. Contrary to single domain works such as [23, 30, 35, 36] that incorporate dictionaries into CNNs, the domain-adaptive dictionary atoms are independently learned from the corresponding domain data to model domain shifts, and the shared decomposed coefﬁcients are learned from the massive data from multiple domains. Note that thanks to this proposed structure, only a small amount of additional parameters is required here to model each additional domain, typically a few hundred.
Figure 2: The proposed domain-adaptive ﬁlter decompo-sition for domain-invariant learning.
With the above domain-adaptive ﬁlter decomposition, at each branched layer, a regular convolution is now decomposed into two: First, a domain-speciﬁc atom convolves each individual input channel for domain shift “correction.” Second, the “corrected" output channels are weighted summed using domain-shared decomposition coefﬁcients (1×1 convolution) to promote common semantics. A toy example is presented in supplementary material Figure A.1 for illustrating the intuition behind the reason why manipulating dictionary atoms alone can address domain shifts. We generate target domain data by applying two trivial operations to source domain images: First, every 3 × 3 non-overlapping patch in each image is locally rotated by 90o. Then, images are negated by multiplying with −1. Domain-invariant features are observed by manipulating dictionary atoms alone. We will 3
rigorously prove in Section 3 why such layer-wise “correction” aligns features across domains, and present real-world examples in the experiments.
Parameters and Computation Reduction. Suppose that both input and output features have the same spatial resolution of W × W , in each forward pass in a regular convolutional layer, there are totally W 2 × C (cid:48) × C × (2L2 + 1) ﬂops for each domain. While in our model, each domain only introduces W 2 ×C (cid:48) ×2K(L2 +C) ﬂops, where K is the number of dictionary atoms. For parameters, there are totally D × C (cid:48) × C × L2 parameters in a regular convolutional layer where D is the number of domains which is typically 2 in our case. In our model, each layer has only K × (C (cid:48) × C + D × L2) parameters. Taking VGG-16 [29] as an example with an input size of 224 × 224, a regular VGG-16 with branching, Fig 1(b) and [25, 26], requires adding 14.71M parameters and 15.38G ﬂops in convolutional layers to handle each additional domain. With the proposed method (Fig 1(c)), VGG-16 only requires adding 702 parameters and 10.75G ﬂops to handle one additional domain (K=6). 3 Provable Invariance with Adaptive Atoms
In this section, we theoretically prove that the features produced by the source and target networks from domain-transferred inputs can be aligned by the proposed framework of only adjusting multi-layer atoms, assuming a generative model of the source and target domain images via CNN. Since convolutional generative networks are a rich class of models for domain transfer [13, 22], our analysis provides a theoretical justiﬁcation of the proposed approach, providing a contribution to the theoretical foundations of domain adaptation. Diverse examples in the experiment section show the applicability of the proposed approach is potentially larger than what is proved here. All proofs are in the supplementary material Section D.
Filter Transform via Atom Transform. Let ws and wt be the ﬁlters in the branched convolutional layer for the source and target domains respectively, and similarly denote the source and target atoms by ψk,s and ψk,t. In the proposed atom decomposition architecture, the source and target domain
ﬁlters are linear combinations of the domain-speciﬁc dictionary atoms with shared decomposition coefﬁcients, namely ws(u) = (cid:88) k akψk,s(u), wt(u) = (cid:88) k akψk,t(u).
Certain transforms of the ﬁlter can be implemented by only transforming the dictionary atoms, including (1) A linear correspondence of ﬁlter values. Let λ : R → R be a linear mapping, by linearity,
ψk,s(u) → ψk,t(u) = λ(ψk,s(u)) applies ws(u) → wt(u) = λ(ws(u)).
E.g. the negation λ(ξ) = −λ(ξ), as shown in supplementary material Figure A.1. (2) The transformation induced by a displacement of spatial variable, i.e., “spatial transform” of ﬁlters, deﬁned as Dτ w(u) = w(u − τ (u)), where τ : R2 → R2 is a differentiable displacement ﬁeld. Note that the dependence on spatial variable u in a ﬁlter is via the atoms, thus ψk,s → ψk,t = Dτ ψk,s applies ws → wt = Dτ ws.
If such ﬁlter adaptations are desired in the branching network, then it sufﬁces to branch the dictionary atoms while keeping the coefﬁcients ak shared, as implemented in the proposed architecture shown in Figure 1(c). A fundamental question is thus how large is the class of possible domain shifts that can be corrected by these “allowable” ﬁlter transforms. In the rest of the section, we show that if the domain shifts in the images are induced from a generative CNN where the ﬁlters for source and target differ by a sequence of allowable transforms, then the domain shift can be provably eliminated by another sequence of ﬁlter transforms which can be implemented by atom branching only.
Provable Invariance. Stacking the approximate commuting relation, Lemma 1 in supplementary material Section D, in multiple layers allows to correct a sequence of ﬁlter transforms in previous convolutional layers by another sequence of “symmetric” ones. This means that if we impose a convolutional generative model on the source and target input images, and assume that the domain transfer results from a sequence of spatial transforms of ﬁlters in the generative net, then by correcting 4
these ﬁlter transforms in the subsequent convolutional layers we can guarantee the recovery of the same feature mapping. The key observation is that the ﬁlter transfers can be implemented by atoms transfer only.
We summarize the standard theoretical assumptions as follows: (A1) The nonlinear activation function σ in any layer is non-expansive, (A2) In the generative net (where layer is indexed by negative integers), w(−l)
, where t
Dl = Dτl , τl is odd and |∇τl|∞ ≤ ε < 1 5 for all l = 1, · · · , L. The biases in the target generative net are mildly adjusted accordingly due to technical reasons (to preserve the
“baseline output” from zero-input, c.f. detail in the proof).
= Dlw(−l) s (A3) In the generative net, (cid:107)w(−l) (cid:107)1 ≤ 1 for all l, and so is w(−l)
. Same for the feed-forward convolutional net taking the generated images as input, called “feature net”:
The source net ﬁlters have (cid:107)w(l) s which will be set to be w(l) t s (cid:107)1 ≤ 1 for l = 1, 2 · · · , and same with Dlw(l) and w(l) s are both supported on 2jl B for l = 1, · · · , L.
. Also, w(−l)
= Dlw(−l) s s s t
One can show that (cid:107)Dτ w(cid:107)1 = (cid:107)w(cid:107)1 when (Id − ρ) is a rigid motion, and generally |(cid:107)Dτ w(cid:107)1 − (cid:107)w(cid:107)1| ≤ c|∇τ |∞(cid:107)w(cid:107)1 which is negligible when ε is small. Thus in (A3) the boundedness of the 1-norm of the source and target ﬁlters imply one another exactly or approximately. The boundedness of 1-norm of the ﬁlters preserves the non-expansiveness of the mapping from input to output in a convolutional layer, and in practice is qualitatively preserved by normalization layers. Also, as a typical setting, (A3) assumes that the scales jl in the generative net (the (−l)-th layer) and the feature net (the l-th layer) are matched, which simpliﬁes the analysis and can be relaxed.
Theorem 1. Suppose that Xs and Xt are source and target images generated by L-layer gener-ative CNN nets with source and target ﬁlters w(−l) respectively from the common repre-s sentation h. Under (A1)-(A3), the output at the L-th layer of the target feature CNN from Xt, by setting w(l) in all layers which can be implemented by atom branching, approxi-mates that of the source feature CNN from Xs up to an error which is bounded in 1-norm by (cid:110) ((cid:80)L
, and the second term vanishes if (Id − τl) are rigid motions, e.g., 4ε rotation. l=1 2jl )(cid:107)∇h(cid:107)1 + 2L(cid:107)h(cid:107)1 t = Dlw(l)
, w(−l) t (cid:111) s 4 Experiments
In this section, we perform extensive experiments to evaluate the performance of the proposed domain-adaptive ﬁlter decomposition. We start with the comparisons among the 3 architectures listed in Figure 1 on two supervised tasks. To demonstrate the proposed framework as one principled way for domain-invariant learning, we then conduct a set of domain adaptation experiments. There we show, by simply plugging the proposed domain ﬁlter decomposition into regular CNNs used in existing domain adaptation methods, we consistently observe performance improvements, which well-illustrate that our method is orthogonal to other domain adaptation methods. 4.1 Architecture Comparisons
We start with two supervised tasks performed on the three architectures listed in Figure 1, regular
CNN (A1), basic branching (A2), and branching with domain-adaptive ﬁlter decomposition (A3).
The networks with DAFD are trained end-to-end with a summed loss for domains, and the domain-speciﬁc atoms are only updated by the error from the corresponding domain, while the decomposition coefﬁcients are updated by the joint error across domains.
Supervised domain adaptation on images. The ﬁrst task is supervised domain adaptation, where we adopt a challenging setting by using MNIST as the source domain, and SVHN as the target domain. We perform a series of experiments by progressively reducing the annotated training data for the target domain. We start the comparisons at 10% of the target domain labeled samples, and end at 0.5% where only 366 labeled samples are available for the target domain. The results on test set for both domains are presented in Table 1. It is clearly shown that when training the target domain with small amount of data, a network with basic branching suffers from overﬁtting to the target domain 5
Table 1: Accuracy (%) on MNIST->SVHN for supervised domain adaptation. A1, A2, and A3 correspond to regular CNN, basic branching, and branching with DAFD shown in Figure 1, respectively.
Scales
Source domain 0.05 0.005 0.1
Target domain 0.05 0.005 0.1
A1
A2
A3 98.4 99.2 99.4 96.4 98.6 98.8 98.0 97.6 98.8 81.6 81.4 85.6 80.2 78.4 82.2 61.0 49.6 64.4
Table 2: Cross-domain simultaneous face recognition on NIR-VIS-2.0. A1, A2, and A3 correspond to regular CNN, basic branching, and branching with domain-adaptive ﬁlter de-composition shown in Figure 1, respectively.
Methods VIS Acc (%) NIR Acc (%) NIR+VIS (%)
A1
A2
A3 75.57 94.46 97.16 52.71 87.50 95.03 98.44 98.58 99.15 because of the large amount of domain speciﬁc parameters. While regular CNN generates well on target domain, the performance on source domain degrades when the number of target domain data is comparable. A network with the proposed domain-adaptive ﬁlter decomposition signiﬁcantly balances the learning of both the source and the target domain, and achieves best accuracies on both domains regardless of the amount of annotated training data for the target domain. The feature space of the three candidate architectures are visualized in Figure 3. (a) Feature space in (a) (b) Feature space in (b) (c) Feature space in (c)
Figure 3: The feature space of the three candidate architectures in Figure 1, MNIST → SVHN, are visualized using t-SNE [21] in (a), (b), (c), respectively. The obtained superior cross-domain invariance of the proposed framework can be clearly observed in (c).
Supervised simultaneous cross-domain face recognition. Besides standard domain adaptation, the proposed domain-adaptive ﬁlter decomposition can be extended to general tasks that involves more than one visual domain; domain adaptation is performed without loosing the power of the original domain and multiple-domains can be simultaneously exploited. Here we demonstrate this by performing experiments on supervised cross-domain face recognition. We adopt the NIR-VIS 2.0 [16], which consists of 17,580 NIR (near infrared) and VIS (visible light) face images of 725 subjects, and perform cross-domain face recognition. We adopt VGG16 as the base network structure, branch all the convolutional layers with the proposed domain-adaptive ﬁlter decomposition, and train the network from scratch. In each convolutional layer, two set of dictionary atoms are trained for modeling the NIR and the VIS domain, respectively. Speciﬁcally, one VIS image and one NIR image are fed simultaneously to the network, and the feature vectors of both domains are averaged to produce the ﬁnal cross-domain feature, which is further fed into a linear classiﬁer for classifying the identity. While the training is conducted using both domains simultaneously, we test the network under three settings including feeding single domain inputs only (VIS Acc and NIR Acc in Table 2) and both domain inputs (VIS+NIR Acc in Table 2). Quantitative comparisons demonstrate that branching with the proposed DAFD performs superiorly even with a missing input domain. Note that A2 requires additional 14.71M parameters over A1, while our method requires only 0.0007M as shown in supplementary material Table A.1. 4.2 Experiments on Standard Domain Adaptations
In this section, we perform extensive experiments on unsupervised domain adaptation. Note that the objective of the experiments in this section is not to validate the proposed domain-adaptive
ﬁlter decomposition as just another new method for domain adaptation. Instead, since most of the state-of-the-art domain adaptation methods adopt the regular CNN (A1) with completely shared pa-rameters for domains, we show the compatibility and the generality of the proposed domain-adapting 6
ﬁlter decomposition by plugging it into underlying domain adaptation methods, and evaluate the effectiveness by retraining the networks using exactly the same setting and observing the performance improvement over the underlying methods. Diverse real-world domain shifts including different sensors, different image sources, and synthetic images, and applications on both classiﬁcation and segmentation are examined in these experiments. Together with the experiments in the previous section, this further stresses the plug-and-play virtue of the proposed framework.
In practise, instead of learning independent source and target domain atoms, we learn the residual between the source and the target do-main atoms. The residual is initialized by full zeros, and trained by loss for encouraging in-variant features in the underlying methods, e.g., the adversarial loss in ADDA [33]. We consis-tently observe that this stabilizes the training and promotes faster convergence.
Table 3: Accuracy (%) on Digits for unsupervised domain adaptation.
M → U U → M
S → M
Methods
DANN
ADDA
CDAN+E
DANN + DAFD
ADDA + DAFD
CDAN+E + DAFD
-89.4 95.6 92.0 91.4 96.8
-90.1 98.0 95.2 94.8 98.8 73.9 76.0 89.2
Avg.
-85.1 94.3 82.1 (11.1% ↑) 82.9 96.6 89.8 89.7 (5.5% ↑) 97.4 (3.2% ↑)
Image classiﬁcation. We perform experiments on three public digits datasets: MNIST, USPS, and
Street View House Numbers (SVHN), with three transfer tasks: USPS to MNIST (U → M), MNIST to USPS (M → U), and SVHN to MNIST (S → M). Classiﬁcation accuracy on the target domain test set samples is adopted as the metric for measuring the performance. We perform domain-adaptive domain decomposition on state-of-the-art methods DANN [6], ADDA [33], and CDAN+E [18].
Quantitative comparisons are presented in Table 3, demonstrating signiﬁcant improvements over underlying methods.
Ofﬁce-31. Ofﬁce-31 [27] is one of the most widely used datasets for visual domain adaptation, which has 4,652 images and 31 categories collected from three distinct domains: Amazon (A),
Webcam (W), and DSLR (D). We evaluate all methods on six transfer tasks A → W, D → W, W →
D, A → D, D → A, and W → A. Two feature extractors, AlexNet [14] and ResNet [9] are adopted for fair comparisons with underlying methods. Speciﬁcally, ImageNet initialization are widely used for
ResNet in the experiments with Ofﬁce-31, and we consistently observe that initialization is important for the training on Ofﬁce-31. Therefore, when training ResNet based networks with domain-adaptive
ﬁlter decomposition, we initialize the feature extractor using parameters decomposed from ImageNet initialization. The quantitative comparisons are in Table 4.
Table 4: Accuracy (%) on Ofﬁce-31 for unsupervised domain adaptation (AlexNet and ResNet). t e
N x e l
A t e
N s e
R
Method
A → W
D → W
W → D
A → D
D → A
W → A
AlexNet (no adaptation)
DANN [6]
ADDA [33]
DANN + DAFD
ADDA + DAFD
ResNet-50 (no adaptation)
DANN [6]
ADDA [33]
CDAN+E [18]
CAN [5]
DANN + DAFD
ADDA + DAFD
CDAN+E + DAFD
CAN + Ours 61.6±0.5 73.0±0.5 73.5±0.6 74.4±0.3 77.2±0.5 68.4±0.2 82.0±0.4 86.2±0.5 94.1±0.1 94.5±0.3 86.4±0.4 86.8±0.4 95.6±0.1 95.2±0.2 95.4±0.3 96.4±0.3 96.2±0.4 97.1±0.4 97.9±0.4 96.7±0.1 96.9±0.2 96.2±0.3 98.6±0.1 99.1±0.2 96.8±0.2 97.7±0.1 98.8±0.1 99.2±0.2 99.0±0.2 99.2±0.3 98.8±0.4 99.1±0.4 98.5±0.2 99.3±0.1 99.1±0.1 98.4±0.3 100.0±.0 99.8±0.2 99.2±0.1 98.4±0.1 100.0±0.0 99.9±0.1 63.8±0.5 72.3±0.3 71.6±0.4 74.2±0.3 73.2±0.4 68.9±0.2 79.7±0.4 77.8±0.3 92.9±0.2 95.0±0.3 84.4±0.4 80.5±0.3 93.5±0.2 96.1±0.2 51.1±0.6 53.4±0.4 54.6±0.5 56.8±0.5 55.4±0.6 62.5±0.3 68.2±0.4 69.5±0.4 71.0±0.3 78.0±0.3 70.5±0.4 71.1±0.4 76.6±0.5 78.9±0.3 49.8±0.4 51.2±0.5 53.5±0.6 53.1±0.7 57.8±0.5 60.7±0.3 67.4±0.5 68.9±0.5 69.3±0.3 77.0±0.3 68.8±0.4 69.1±0.5 71.3±0.4 78.2±0.3
Avg. 70.1 74.3 74.7 75.8 (2.3% ↑) 76.7 (2.7% ↑) 76.1 82.2 82.9 87.7 90.6 84.35 (2.3% ↑) 83.9 (1.2% ↑) 89.3 (1.8% ↑) 91.27 (0.7% ↑)
Image segmentation. Beyond image classiﬁcation tasks, we perform a challenging experiment on image segmentation to demonstrate the generality of the proposed domain-adaptive ﬁlter decom-position. We perform unsupervised adaptation from the GTA dataset [24] (images generated from video games) to the Cityscapes dataset [4] (real-world images), which has a signiﬁcant practical value considering the expensive cost on collecting annotations for image segmentation in real-world scenarios. Two underlying methods FCNs in the wild [12] and AdaptSegNet [31] are adopted for comprehensive comparisons. Based on the underlying methods, all the convolutional layers are decomposed using domain-adaptive ﬁlter decomposition, and all the transpose-convolutional layers are kept sharing by both domains. For quantitative results in Table 5, we use intersection-over-union, 7
TP
TP+FP+FN , where TP, FP, and FN are the numbers of true positive, false positive, and i.e., IoU = false negative pixels, respectively, as the evaluation metric. As with the previous examples, our method improves all state-of-the-art architectures. Qualitative results are shown in Figure 4 and supplementary material Figure A.2, and data samples are in Figure 5.
Table 5: Unsupervised DA for semantic segmentation: GTA → Cityscapes
Methods
No Adapt (VGG)
No Adapt (ResNet)
FCN WLD (VGG)
AdaptSegNet (VGG)
AdaptSegNet (ResNet)
IoU 17.9 36.6 27.1 35.0 42.4
FCN WLD + DAFD
AdaptSegNet (VGG) + DAFD
AdaptSegNet (ResNet) + DAFD 32.7 (20.7% ↑) 36.4 (4.0% ↑) 45.0 (6.1% ↑) sidew alk building 14.9 16.8 32.4 29.8 36.0 36.7 35.3 38.5 65.1 77.2 62.1 78.6 79.9 68.8 78.8 8.12 road 26.0 75.8 70.4 87.3 86.5 76.4 86.7 88.2 w all 5.5 12.5 14.9 21.1 23.4 17.6 22.8 25.0 fence 12.9 21.0 5.4 18.2 23.3 5.8 14.5 23.8 pole 8.9 25.5 10.9 22.5 23.9 11.1 23.9 22.9 t-light 6.0 30.1 14.2 21.5 35.2 13.9 21.9 35.1 t-sign 2.5 20.1 2.7 11.0 14.8 2.9 18.2 14.4
Class-wide IoU veg 70.0 81.3 79.2 79.7 83.4 80.0 82.1 84.9 terrain 2.9 24.6 21.3 29.6 33.3 24.4 32.2 34.1 sky 47.0 70.3 64.6 71.3 75.6 69.1 66.8 79.9 person 24.5 53.8 44.1 46.8 58.5 47.5 49.6 59.5 rider 0.0 26.4 4.2 6.5 27.6 4.3 10.1 29.1 car 40.0 49.9 70.4 80.1 73.7 74.4 81.2 75.5 truck 12.1 17.2 8.0 23.0 32.5 14.1 19.6 30.1 bus 1.5 25.9 7.3 26.9 35.4 6.3 27.1 35.2 train 0.0 6.5 0.0 0.0 3.9 0.0 1.1 2.9 m bike 0.0 25.3 3.5 10.6 30.1 2.1 11.4 28.7 bicycle 0.0 36.0 0.0 0.3 28.1 0.0 4.2 29.1 (a) Target domain image. (b) Before adaptation. (c) After adaptation. (d) Ground truth.
Figure 4: Qualitative results for domain adaptation segmentation. The samples are randomly selected from the validation subsets of Cityscapes. (a) Source domain (GTA: video game images). (b) Target domain (Cityscapes: real-world images).
Figure 5: Dataset samples for segmentation experiments (video games → street views). 5